provide(function(t){using("lib/component","lib/advice","lib/utils",function(e,n){var i=function(){return e(function(){})}();describe("(Core) advice",function(){afterEach(function(){i.teardownAll()}),it('should call the "before" function before the base function and return the base function',function(){function t(t){return e+="Base: "+t,"base"}var e="",i=n.before(t,function(t){return e+="Before: "+t+", ","before"});expect(i("Dan")).toBe("base"),expect(e).toBe("Before: Dan, Base: Dan")}),it('should call the "after" function after the base function, but return the base function',function(){function t(t){return e+="Base: "+t,"base"}var e="",i=n.after(t,function(t){return e+=", After: "+t,"after"});expect(i("Dan")).toBe("base"),expect(e).toBe("Base: Dan, After: Dan")}),it('should wrap the the first "around" argument with the second argument',function(){function t(t){return e+="Base: "+t,"base"}var e="",i=n.around(t,function(t,n){return e+="|",t(n),e+="|","around"});expect(i("Dan")).toBe("around"),expect(e).toBe("|Base: Dan|")}),describe("withAdvice",function(){it('should add "before", "after" and "around" to an object',function(){var t={testa:"",testb:"",testc:"",a:function(){this.testa+="A!"},b:function(){this.testb+="B!"},c:function(){this.testc+="C!"}};n.withAdvice.call(t),t.before("a",function(){this.testa+="BEFORE!"}),t.after("b",function(){this.testb+="AFTER!"}),t.around("c",function(e){this.testc+="|",e.call(t),this.testc+="|"}),t.a(),expect(t.testa).toBe("BEFORE!A!"),t.b(),expect(t.testb).toBe("B!AFTER!"),t.c(),expect(t.testc).toBe("|C!|")})})}),t(1)})});